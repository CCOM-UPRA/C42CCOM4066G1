"""This script processes a CSV file generated by L1PD containing patterns
that are considered to be L1s and compares those L1s against L1Base2 to
filter out those L1s that do not have a corresponding match.
Note: By default L1PD generates a GFF3 file, but a CSV file is required here.
"""

import argparse
import sys, os
sys.path.append(os.path.join(os.path.dirname(__file__), '..', 'L1PD_files'))
#echo sys
#sys.path.append('../L1PD_files/')
#echo sys
#from ..L1PD_files import l1base2
import l1base2

# Global variables
L1sByChr = posStartL1 = L1sFound = None


def find_L1(pos, chromosome, offsetORF1, kmerSize, threshold):
	"""Returns the L1Base2 index of the corresponding L1 or -1 if no such L1.

	Check if position of probe hit is within the threshold of the expected
	position of k-mer corresponding to a LINE-1.
	If that is the case, return the index of that L1, or -1 otherwise.
	"""

	global L1sFound, posStartL1 # posStartL1 is used to print later if L1 is found

	if chromosome in L1sByChr: # Not all chromosomes have L1s
		for indexL1 in L1sByChr[chromosome]:
			if pos >= 0: # Forward strand
				# pos - offsetORF1 places us at the beginning of ORF1,
				#     - ORF1Start then places us at the beginning of the L1
				posStartL1 = pos - offsetORF1 - (int(l1base2.CSV[indexL1]["ORF1 Start"]) - 1)
			else: # Reverse strand
				# Similar to forward strand, but need to take into account kmerSize
				# to move to beginning of kmer first.
				posStartL1 = (-pos) + kmerSize + offsetORF1 + (int(l1base2.CSV[indexL1]["ORF1 Start"]) - 1)
			actDistDiff = abs(posStartL1 -  int(l1base2.CSV[indexL1]["Start"]))
			if actDistDiff <= threshold:
				return indexL1
	# If still here, no corresponding L1 was found in L1Base2
	return -1


def get_data(txtLine):
	"""Return chromosome, k-mer index and k-mer position of first k-mer in pattern.
	
	Converts the tab-separated line into a 3-element tuple that is returned.
	The first element is the chromosome, the second is the index of the first
	probe of the pattern, and the third element is the position where that probe
	was found.  The other probes of the pattern are disregarded.
	Sample input: 21	(6, 19149834)	(8, 19150117)	(9, 19150162)	(10, 19150959)
	Sample output: (21, 6, 19149834)
	"""

	pieces = txtLine.split('\t')
	chromosome = pieces[0]
	return (chromosome,) + eval(pieces[1]) # eval converts '(#, #)' string into a tuple


def main(PatternsCSVFile, ProbesFile, threshold, CSVDIR):
	"""Filter out all patterns that don't correspond to L1s and print the rest.

	Parameters:
		PatternsCSVFile - Contains the patterns detected by L1PD, in following format:
		                  chrm\t(probeIndex1, probePos)\t(probeIndex2,probePos)...
		ProbesFile      - FASTA file with the probes and their distance to beg. of ORF1
		threshold       - Allowed max. distance between act. probe pos and exp. pos.
		CSVDIR          - Directory containing the CSV metadata from L1Base2
	"""

	global offsetORF1, kmerSize, L1sByChr, L1sFound

	# First, we process the FASTA file with the probes to store:
	# 1) Offset of each probe to the beginning of ORF1
	# 2) Size of each probe, although it's unclear whether everything
	#    will work if sizes vary
	with open(ProbesFile) as fh:
		ORFOffsets = list()
		kmerSizes = list()
		for line in fh:
			if line.startswith('>'):
				# At end of description of every seq is the dist to beginning of ORF1
				ORFOffsets.append(int(line.rstrip().split(" ")[-1]))
			else:
				kmerSizes.append(len(line.rstrip()))

	# L1Base2 offers metadata for full-length intact L1s (FLI-L1), ORF2 intact L1s
	# (ORF2-L1), and full-length non-intact L1s (FLnI-L1).  We search within these
	# files to see if our L1s match against any of them.  Due to DNA similarity, it
	# is possible for a L1 to match against more than one CSV, but we only count
	# the first such match.
	csvFileList = [file for file in os.listdir(CSVDIR) if file.endswith('fli-l1.csv') or file.endswith('flni-l1.csv') or file.endswith('orf2-l1.csv')]
	L1PatFoundCount = dict() # Track which patterns were matched to L1s
	for L1Base2CSVFile in csvFileList:
		L1CSV = l1base2.load_CSV_file(CSVDIR + L1Base2CSVFile)
		L1sByChr = l1base2.get_L1s_by_chr()
		L1sFound = [ 0 ] * len(L1CSV)

		linesPatCSV = 0
		# Moved to before for loop: L1PatFoundCount = dict() DEBUG?
		with open(PatternsCSVFile) as fhCSV:
			for line in fhCSV:
				linesPatCSV += 1
				chrm, index, pos = get_data(line) # A 3-element tuple is returned
				L1Index = find_L1(pos, chrm, ORFOffsets[index], kmerSizes[index], threshold)
				if L1Index > -1:
					L1sFound[L1Index] += 1
					# Find the files where each L1 is found
					L1PatFoundCount[linesPatCSV-1] = L1PatFoundCount.get(linesPatCSV-1, []) + [(L1Base2CSVFile, chrm, L1Index, pos)]

					# File name at beginning, start position and index of L1 after chromosome
					tabPos = line.find("\t")
					if len(L1PatFoundCount[linesPatCSV-1]) <= 1:
						# Print duplicate if already found in this CSV file
						if L1sFound[L1Index] > 1:
							print("DUPLICATE\t"+line[:tabPos+1]+str(L1Index+1)+"\t"+str(posStartL1)+"\t"+line[tabPos+1:-1])
						else: # Print which CSV file it was first found in
							print(L1Base2CSVFile+"\t"+line[:tabPos+1]+str(L1Index+1)+"\t"+str(posStartL1)+"\t"+line[tabPos+1:-1])

						# The precision_recall script will only count the lines without the DUPLICATE string


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Filter out L1s in CSV by matching against L1Base2")
    parser.add_argument("CSV", help="Full path to CSV file with possible L1s")
    parser.add_argument("FASTA", help="Full path to fasta file with k-mer probes")
    parser.add_argument("-t", "--threshold", type=int, default=700, help="Maximum allowed difference between expected distance between k-mers and actual distance")
    parser.add_argument("--data_dir", help="Full path to directory with L1Base2 metadata in CSV format")
    args = parser.parse_args()
    main(args.CSV, args.FASTA, args.threshold, args.data_dir)
